<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Advanced Performance | React</title>
  <meta name="viewport" content="width=device-width">
  <meta property="og:title" content="Advanced Performance | React">
  <meta property="og:type" content="website">
  <meta property="og:url" content="http://facebook.github.io/react/docs/advanced-performance.html">
  <meta property="og:image" content="http://facebook.github.io/react/img/logo_og.png">
  <meta property="og:description" content="A JavaScript library for building user interfaces">
  <meta property="fb:app_id" content="623268441017527">

  <link rel="shortcut icon" href="/react/favicon.ico">
  <link rel="alternate" type="application/rss+xml" title="React" href="http://facebook.github.io/react/feed.xml">

  <link rel="stylesheet" href="/react/css/syntax.css">
  <link rel="stylesheet" href="/react/css/codemirror.css">
  <link rel="stylesheet" href="/react/css/react.css">

  <script type="text/javascript" src="//use.typekit.net/vqa1hcx.js"></script>
  <script type="text/javascript">try{Typekit.load();}catch(e){}</script>

  <!--[if lte IE 8]>
  <script type="text/javascript" src="/react/js/html5shiv.min.js"></script>
  <script type="text/javascript" src="/react/js/es5-shim.min.js"></script>
  <script type="text/javascript" src="/react/js/es5-sham.min.js"></script>
  <![endif]-->
  <script type="text/javascript" src="/react/js/codemirror.js"></script>
  <script type="text/javascript" src="/react/js/javascript.js"></script>
  <script type="text/javascript" src="/react/js/react.js"></script>
  <script type="text/javascript" src="/react/js/JSXTransformer.js"></script>
  <script type="text/javascript" src="/react/js/live_editor.js"></script>
  <script type="text/javascript" src="/react/js/showdown.js"></script>
</head>
<body>

  <div class="container">

    <div class="nav-main">
      <div class="wrap">
        <a class="nav-home" href="/react/index.html">
          <img class="nav-logo" src="/react/img/logo.svg" width="36" height="36">
          React
        </a>
        <ul class="nav-site nav-site-internal">
          <li><a href="/react/docs/getting-started.html" class="active">Docs</a></li>
          <li><a href="/react/support.html">Support</a></li>
          <li><a href="/react/downloads.html">Download</a></li>
          <li><a href="/react/blog/">Blog</a></li>
        </ul>

        <ul class="nav-site nav-site-external">
          <li><a href="https://github.com/facebook/react">GitHub</a>
          <li><a href="http://facebook.github.io/react-native/">React Native</a>
        </ul>
      </div>
    </div>

    

    <section class="content wrap documentationContent">
  <div class="nav-docs">
  <!-- Docs Nav -->
  
    <div class="nav-docs-section">
      <h3>Quick Start</h3>
      <ul>
        
          <li>
            <a href="/react/docs/getting-started-ko-KR.html">시작해보기</a>
            
          </li>
        
          <li>
            <a href="/react/docs/tutorial-ko-KR.html">튜토리얼</a>
            
          </li>
        
          <li>
            <a href="/react/docs/thinking-in-react-ko-KR.html">리액트로 생각해보기</a>
            
          </li>
        
      </ul>
    </div>
  
    <div class="nav-docs-section">
      <h3>Community Resources</h3>
      <ul>
        
          <li>
            <a href="/react/docs/conferences-ko-KR.html">컨퍼런스들</a>
            
          </li>
        
          <li>
            <a href="/react/docs/videos-ko-KR.html">비디오들</a>
            
          </li>
        
          <li>
            <a href="/react/docs/complementary-tools-ko-KR.html">상호 보완적인 도구들</a>
            
          </li>
        
          <li>
            <a href="/react/docs/examples-ko-KR.html">예제들</a>
            
          </li>
        
      </ul>
    </div>
  
    <div class="nav-docs-section">
      <h3>Guides</h3>
      <ul>
        
          <li>
            <a href="/react/docs/why-react-ko-KR.html">왜 React인가?</a>
            
          </li>
        
          <li>
            <a href="/react/docs/displaying-data-ko-KR.html">데이터를 표시하기</a>
            
              <ul>
                
                  <li>
                    <a href="/react/docs/jsx-in-depth-ko-KR.html">JSX 깊이보기</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/jsx-spread-ko-KR.html">JSX 스프레드 어트리뷰트</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/jsx-gotchas-ko-KR.html">JSX Gotchas</a>
                  </li>
                
              </ul>
            
          </li>
        
          <li>
            <a href="/react/docs/interactivity-and-dynamic-uis-ko-KR.html">상호 작용 및 동적 UI</a>
            
          </li>
        
          <li>
            <a href="/react/docs/multiple-components-ko-KR.html">복합 컴포넌트</a>
            
          </li>
        
          <li>
            <a href="/react/docs/reusable-components-ko-KR.html">재사용가능한 컴포넌트</a>
            
          </li>
        
          <li>
            <a href="/react/docs/transferring-props-ko-KR.html">Props 전달</a>
            
          </li>
        
          <li>
            <a href="/react/docs/forms-ko-KR.html">폼</a>
            
          </li>
        
          <li>
            <a href="/react/docs/working-with-the-browser-ko-KR.html">브라우저에서의 동작</a>
            
              <ul>
                
                  <li>
                    <a href="/react/docs/more-about-refs-ko-KR.html">refs 심화</a>
                  </li>
                
              </ul>
            
          </li>
        
          <li>
            <a href="/react/docs/tooling-integration-ko-KR.html">툴 통합</a>
            
          </li>
        
          <li>
            <a href="/react/docs/addons-ko-KR.html">애드온</a>
            
              <ul>
                
                  <li>
                    <a href="/react/docs/animation-ko-KR.html">애니메이션</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/two-way-binding-helpers-ko-KR.html">양방향 바인딩 핼퍼</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/class-name-manipulation-ko-KR.html">클래스 이름 조작</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/test-utils-ko-KR.html">테스트 유틸리티</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/clone-with-props-ko-KR.html">ReactElement 클론하기</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/create-fragment-ko-KR.html">키가 할당된 프래그먼트</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/update-ko-KR.html">불변성 헬퍼들</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/pure-render-mixin-ko-KR.html">PureRenderMixin</a>
                  </li>
                
                  <li>
                    <a href="/react/docs/perf-ko-KR.html">성능 도구</a>
                  </li>
                
              </ul>
            
          </li>
        
          <li>
            <a href="/react/docs/advanced-performance-ko-KR.html">성능 심화</a>
            
          </li>
        
      </ul>
    </div>
  
    <div class="nav-docs-section">
      <h3>Reference</h3>
      <ul>
        
          <li>
            <a href="/react/docs/top-level-api-ko-KR.html">최상위 API</a>
            
          </li>
        
          <li>
            <a href="/react/docs/component-api-ko-KR.html">컴포넌트 API</a>
            
          </li>
        
          <li>
            <a href="/react/docs/component-specs-ko-KR.html">컴포넌트 명세와 생명주기</a>
            
          </li>
        
          <li>
            <a href="/react/docs/tags-and-attributes-ko-KR.html">태그와 어트리뷰트</a>
            
          </li>
        
          <li>
            <a href="/react/docs/events-ko-KR.html">이벤트 시스템</a>
            
          </li>
        
          <li>
            <a href="/react/docs/dom-differences-ko-KR.html">DOM과의 차이점</a>
            
          </li>
        
          <li>
            <a href="/react/docs/special-non-dom-attributes-ko-KR.html">DOM이 아닌 특별한 어트리뷰트</a>
            
          </li>
        
          <li>
            <a href="/react/docs/reconciliation-ko-KR.html">비교조정</a>
            
          </li>
        
          <li>
            <a href="/react/docs/glossary-ko-KR.html">React (가상) DOM 용어</a>
            
          </li>
        
      </ul>
    </div>
  
    <div class="nav-docs-section">
      <h3>Flux</h3>
      <ul>
        
          <li>
            <a href="http://facebook.github.io/flux/docs/overview.html">Flux Overview</a>
            
          </li>
        
          <li>
            <a href="http://facebook.github.io/flux/docs/todo-list.html">Flux TodoMVC Tutorial</a>
            
          </li>
        
      </ul>
    </div>
  

  <!-- Tips Nav -->
  
    <div class="nav-docs-section">
      <h3>Tips</h3>
      <ul>
        
          <li>
            <a href="/react/tips/introduction-ko-KR.html">개요</a>
          </li>
        
          <li>
            <a href="/react/tips/inline-styles-ko-KR.html">인라인 스타일</a>
          </li>
        
          <li>
            <a href="/react/tips/if-else-in-JSX-ko-KR.html">JSX에서 If-Else</a>
          </li>
        
          <li>
            <a href="/react/tips/self-closing-tag-ko-KR.html">자기 자신을 닫는 태그</a>
          </li>
        
          <li>
            <a href="/react/tips/maximum-number-of-jsx-root-nodes-ko-KR.html">JSX 루트 노드의 최대 갯수</a>
          </li>
        
          <li>
            <a href="/react/tips/style-props-value-px-ko-KR.html">스타일 속성에서 특정 픽셀 값 넣는 간단한 방법</a>
          </li>
        
          <li>
            <a href="/react/tips/children-props-type-ko-KR.html">자식 속성들의 타입</a>
          </li>
        
          <li>
            <a href="/react/tips/controlled-input-null-value-ko-KR.html">제어되는 input 내의 null 값</a>
          </li>
        
          <li>
            <a href="/react/tips/componentWillReceiveProps-not-triggered-after-mounting-ko-KR.html">마운트 후에는 componentWillReceiveProps가 실행되지 않음</a>
          </li>
        
          <li>
            <a href="/react/tips/props-in-getInitialState-as-anti-pattern-ko-KR.html">getInitialState의 Props는 안티패턴</a>
          </li>
        
          <li>
            <a href="/react/tips/dom-event-listeners-ko-KR.html">컴포넌트에서 DOM 이벤트 리스너</a>
          </li>
        
          <li>
            <a href="/react/tips/initial-ajax-ko-KR.html">AJAX를 통해 초기 데이터 읽어오기</a>
          </li>
        
          <li>
            <a href="/react/tips/false-in-jsx-ko-KR.html">JSX에서 False</a>
          </li>
        
          <li>
            <a href="/react/tips/communicate-between-components-ko-KR.html">컴포넌트간의 통신</a>
          </li>
        
          <li>
            <a href="/react/tips/expose-component-functions-ko-KR.html">컴포넌트 함수 드러내기</a>
          </li>
        
          <li>
            <a href="/react/tips/references-to-components-ko-KR.html">컴포넌트 참조</a>
          </li>
        
          <li>
            <a href="/react/tips/children-undefined-ko-KR.html">정의되지 않은 this.props.children</a>
          </li>
        
          <li>
            <a href="/react/tips/use-react-with-other-libraries-ko-KR.html">React와 다른 라이브러리를 함께 사용하기</a>
          </li>
        
          <li>
            <a href="/react/tips/dangerously-set-inner-html.html">Dangerously Set innerHTML</a>
          </li>
        
      </ul>
    </div>
  
</div>


  <div class="inner-content">
    <h1>
      Advanced Performance
      <a class="edit-page-link" href="https://github.com/reactkr/react/blob/translation/docs/docs/11-advanced-performance.md" target="_blank">Edit on GitHub</a>
    </h1>
    <div class="subHeader"></div>

    <p>One of the first questions people ask when considering React for a project is whether their application will be as fast and responsive as an equivalent non-React version. The idea of re-rendering an entire subtree of components in response to every state change makes people wonder whether this process negatively impacts performance. React uses several clever techniques to minimize the number of costly DOM operations required to update the UI.</p>
<h2><a class="anchor" name="avoiding-reconciling-the-dom"></a>Avoiding reconciling the DOM <a class="hash-link" href="#avoiding-reconciling-the-dom">#</a></h2>
<p>React makes use of a <em>virtual DOM</em>, which is a descriptor of a DOM subtree rendered in the browser. This parallel representation allows React to avoid creating DOM nodes and accessing existing ones, which is slower than operations on JavaScript objects. When a component&#39;s props or state change, React decides whether an actual DOM update is necessary by constructing a new virtual DOM and comparing it to the old one. Only in the case they are not equal, will React <a href="http://facebook.github.io/react/docs/reconciliation.html">reconcile</a> the DOM, applying as few mutations as possible.</p>

<p>On top of this, React provides a component lifecycle function, <code>shouldComponentUpdate</code>, which is triggered before the re-rendering process starts (virtual DOM comparison and possible eventual DOM reconciliation), giving the developer the ability to short circuit this process. The default implementation of this function returns <code>true</code>, leaving React to perform the update:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">shouldComponentUpdate</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">,</span> <span class="nx">nextState</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Keep in mind that React will invoke this function pretty often, so the implementation has to be fast.</p>

<p>Say you have a messaging application with several chat threads. Suppose only one of the threads has changed. If we implement <code>shouldComponentUpdate</code> on the <code>ChatThread</code> component, React can skip the rendering step for the other threads:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">shouldComponentUpdate</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">,</span> <span class="nx">nextState</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// TODO: return whether or not current chat thread is</span>
  <span class="c1">// different to former one.</span>
<span class="p">}</span>
</code></pre></div>
<p>So, in summary, React avoids carrying out expensive DOM operations required to reconcile subtrees of the DOM by allowing the user to short circuit the process using <code>shouldComponentUpdate</code>, and, for those which should update, by comparing virtual DOMs.</p>
<h2><a class="anchor" name="shouldcomponentupdate-in-action"></a>shouldComponentUpdate in action <a class="hash-link" href="#shouldcomponentupdate-in-action">#</a></h2>
<p>Here&#39;s a subtree of components. For each one is indicated what <code>shouldComponentUpdate</code> returned and whether or not the virtual DOMs were equivalent. Finally, the circle&#39;s color indicates whether the component had to be reconciled or not.</p>

<figure><img src="/react/img/docs/should-component-update.png" /></figure>

<p>In the example above, since <code>shouldComponentUpdate</code> returned <code>false</code> for the subtree rooted at C2, React had no need to generate the new virtual DOM, and therefore, it neither needed to reconcile the DOM. Note that React didn&#39;t even have to invoke <code>shouldComponentUpdate</code> on C4 and C5.</p>

<p>For C1 and C3 <code>shouldComponentUpdate</code> returned <code>true</code>, so React had to go down to the leaves and check them. For C6 it returned <code>true</code>; since the virtual DOMs weren&#39;t equivalent it had to reconcile the DOM.
The last interesting case is C8. For this node React had to compute the virtual DOM, but since it was equal to the old one, it didn&#39;t have to reconcile it&#39;s DOM.</p>

<p>Note that React only had to do DOM mutations for C6, which was inevitable. For C8 it bailed out by comparing the virtual DOMs, and for C2&#39;s subtree and C7, it didn&#39;t even have to compute the virtual DOM as we bailed out on <code>shouldComponentUpdate</code>.</p>

<p>So, how should we implement <code>shouldComponentUpdate</code>? Say that you have a component that just renders a string value:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
  <span class="nx">propsTypes</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">value</span><span class="o">:</span> <span class="nx">React</span><span class="p">.</span><span class="nx">PropTypes</span><span class="p">.</span><span class="nx">string</span><span class="p">.</span><span class="nx">isRequired</span>
  <span class="p">},</span>

  <span class="nx">render</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">value</span><span class="o">&lt;</span><span class="err">/div&gt;;</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>We could easily implement <code>shouldComponentUpdate</code> as follow:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">shouldComponentUpdate</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">,</span> <span class="nx">nextState</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">value</span> <span class="o">!==</span> <span class="nx">nextProps</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>So far so good, dealing with such simple props/state structures is easy. We could even generalize an implementation based on shallow equality and mix it into components. In fact, React already provides such implementation: <a href="http://facebook.github.io/react/docs/pure-render-mixin.html">PureRenderMixin</a>.</p>

<p>But what if your components&#39; props or state are mutable data structures?. Say the prop the component receives, instead of being a string like <code>&#39;bar&#39;</code>, is a Javascript object that contains a string such as, <code>{ foo: &#39;bar&#39; }</code>:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
  <span class="nx">propsTypes</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">value</span><span class="o">:</span> <span class="nx">React</span><span class="p">.</span><span class="nx">PropTypes</span><span class="p">.</span><span class="nx">object</span><span class="p">.</span><span class="nx">isRequired</span>
  <span class="p">},</span>

  <span class="nx">render</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">foo</span><span class="o">&lt;</span><span class="err">/div&gt;;</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>The implementation of <code>shouldComponentUpdate</code> we had before wouldn&#39;t always work as expected:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// assume this.props.value is { foo: &#39;bar&#39; }</span>
<span class="c1">// assume nextProps.value is { foo: &#39;bar&#39; },</span>
<span class="c1">// but this reference is different to this.props.value</span>
<span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">value</span> <span class="o">!==</span> <span class="nx">nextProps</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span> <span class="c1">// true</span>
</code></pre></div>
<p>The problem is <code>shouldComponentUpdate</code> will return <code>true</code> when the prop actually didn&#39;t change. To fix this we could come up with this alternative implementation:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">shouldComponentUpdate</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">,</span> <span class="nx">nextState</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">foo</span> <span class="o">!==</span> <span class="nx">nextProps</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Basically, we ended up doing a deep comparison to make sure we properly track changes. This approach is pretty expensive in terms of performance and it doesn&#39;t scale as we would have to write different deep equality code for each model. On top of that, it might not even work if we don&#39;t carefully manage object references. Say this component is used by a parent:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
  <span class="nx">getInitialState</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span> <span class="p">}</span> <span class="p">};</span>
  <span class="p">},</span>

  <span class="nx">onClick</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="nx">value</span><span class="p">.</span><span class="nx">foo</span> <span class="o">+=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span> <span class="c1">// ANTI-PATTERN!</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">value</span> <span class="p">});</span>
  <span class="p">},</span>

  <span class="nx">render</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">InnerComponent</span> <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">value</span><span class="p">}</span> <span class="o">/&gt;</span>
        <span class="o">&lt;</span><span class="nx">a</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onClick</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Click</span> <span class="nx">me</span><span class="o">&lt;</span><span class="err">/a&gt;</span>
      <span class="o">&lt;</span><span class="err">/div&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>The first time the inner component gets rendered it will have <code>{ foo: &#39;bar&#39; }</code> as the value prop. If the user clicks on the anchor, the parent component&#39;s state will get updated to <code>{ value: { foo: &#39;barbar&#39; } }</code>, triggering the re-rendering process of the inner component, which will receive <code>{ foo: &#39;barbar&#39; }</code> as the new value for the prop.</p>

<p>The problem is that since the parent and inner components share a reference to the same object, when the object gets mutated on line 2 of the <code>onClick</code> function, the prop the inner component had will change. So, when the re-rendering process starts, and <code>shouldComponentUpdate</code> gets invoked, <code>this.props.value.foo</code> will be equal to <code>nextProps.value.foo</code>, because in fact, <code>this.props.value</code> references the same object as <code>nextProps.value</code>.</p>

<p>Consequently, since we&#39;ll miss the change on the prop and short circuit the re-rendering process, the UI won&#39;t get updated from <code>&#39;bar&#39;</code> to <code>&#39;barbar&#39;</code>.</p>
<h2><a class="anchor" name="immutable-js-to-the-rescue"></a>Immutable-js to the rescue <a class="hash-link" href="#immutable-js-to-the-rescue">#</a></h2>
<p><a href="https://github.com/facebook/immutable-js">Immutable-js</a> is a Javascript collections library  written by Lee Byron, which Facebook recently open-sourced. It provides <em>immutable persistent</em> collections via <em>structural sharing</em>. Lets see what these properties mean:</p>

<ul>
<li><em>Immutable</em>: once created, a collection cannot be altered at another point in time.</li>
<li><em>Persistent</em>: new collections can be created from a previous collection and a mutation such as set. The original collection is still valid after the new collection is created.</li>
<li><em>Structural Sharing</em>: new collections are created using as much of the same structure as the original collection as possible, reducing copying to a minimum to achieve space efficiency and acceptable performance. If the new collection is equal to the original, the original is often returned.</li>
</ul>

<p>Immutability makes tracking changes cheap; a change will always result in a new object so we only need to check if the reference to the object has changed. For example, in this regular Javascript code:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span><span class="o">:</span> <span class="s2">&quot;bar&quot;</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
<span class="nx">y</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s2">&quot;baz&quot;</span><span class="p">;</span>
<span class="nx">x</span> <span class="o">===</span> <span class="nx">y</span><span class="p">;</span> <span class="c1">// true</span>
</code></pre></div>
<p>Although <code>y</code> was edited, since it&#39;s a reference to the same object as <code>x</code>, this comparison returns <code>true</code>. However, this code could be written using immutable-js as follows:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">SomeRecord</span> <span class="o">=</span> <span class="nx">Immutable</span><span class="p">.</span><span class="nx">Record</span><span class="p">({</span> <span class="nx">foo</span><span class="o">:</span> <span class="kc">null</span> <span class="p">});</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SomeRecord</span><span class="p">({</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span>  <span class="p">});</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">);</span>
<span class="nx">x</span> <span class="o">===</span> <span class="nx">y</span><span class="p">;</span> <span class="c1">// false</span>
</code></pre></div>
<p>In this case, since a new reference is returned when mutating <code>x</code>, we can safely assume that <code>x</code> has changed.</p>

<p>Another possible way to track changes could be doing dirty checking by having a flag set by setters. A problem with this approach is that it forces you to use setters and, either write a lot of additional code, or somehow instrument your classes. Alternatively, you could deep copy the object just before the mutations and deep compare to determine whether there was a change or not. A problem with this approach is both deepCopy and deepCompare are expensive operations.</p>

<p>So, Immutable data structures provides you a cheap and less verbose way to track changes on objects, which is all we need to implement <code>shouldComponentUpdate</code>. Therefore, if we model props and state attributes using the abstractions provided by immutable-js we&#39;ll be able to use <code>PureRenderMixin</code> and get a nice boost in perf.</p>
<h2><a class="anchor" name="immutable-js-and-flux"></a>Immutable-js and Flux <a class="hash-link" href="#immutable-js-and-flux">#</a></h2>
<p>If you&#39;re using <a href="http://facebook.github.io/flux/">Flux</a>, you should start writing your stores using immutable-js. Take a look at the <a href="http://facebook.github.io/immutable-js/docs/#/">full API</a>.</p>

<p>Let&#39;s see one possible way to model the thread example using Immutable data structures. First, we need to define a <code>Record</code> for each of the entities we&#39;re trying to model. Records are just immutable containers that hold values for a specific set of fields:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">User</span> <span class="o">=</span> <span class="nx">Immutable</span><span class="p">.</span><span class="nx">Record</span><span class="p">({</span>
  <span class="nx">id</span><span class="o">:</span> <span class="kc">undefined</span><span class="p">,</span>
  <span class="nx">name</span><span class="o">:</span> <span class="kc">undefined</span><span class="p">,</span>
  <span class="nx">email</span><span class="o">:</span> <span class="kc">undefined</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">Message</span> <span class="o">=</span> <span class="nx">Immutable</span><span class="p">.</span><span class="nx">Record</span><span class="p">({</span>
  <span class="nx">timestamp</span><span class="o">:</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(),</span>
  <span class="nx">sender</span><span class="o">:</span> <span class="kc">undefined</span><span class="p">,</span>
  <span class="nx">text</span><span class="o">:</span> <span class="s1">&#39;&#39;</span>
<span class="p">});</span>
</code></pre></div>
<p>The object the <code>Record</code> function receives defines the fields the object has and their default values.</p>

<p>The messages <em>store</em> could keep track of the users and messages using two lists:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="k">this</span><span class="p">.</span><span class="nx">users</span> <span class="o">=</span> <span class="nx">Immutable</span><span class="p">.</span><span class="nx">List</span><span class="p">();</span>
<span class="k">this</span><span class="p">.</span><span class="nx">messages</span> <span class="o">=</span> <span class="nx">Immutable</span><span class="p">.</span><span class="nx">List</span><span class="p">();</span>
</code></pre></div>
<p>It should be pretty straightforward to implement functions to process each <em>payload</em> type. For instance, when the store sees a payload representing a new message,  we can just create a new record and append it to the messages list:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="k">this</span><span class="p">.</span><span class="nx">messages</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">messages</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">Message</span><span class="p">({</span>
  <span class="nx">timestamp</span><span class="o">:</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">timestamp</span><span class="p">,</span>
  <span class="nx">sender</span><span class="o">:</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span>
  <span class="nx">text</span><span class="o">:</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">text</span>
<span class="p">});</span>
</code></pre></div>
<p>Note that since the data structures are immutable, we need to assign the result of the push function to this.messages.</p>

<p>On the React side, if we also use immutable-js data structures to hold the components&#39; state, we could mix <code>PureRenderMixin</code> into all our components and short circuit the re-rendering process.</p>


    <div class="docs-prevnext">
      
        <a class="docs-prev" href="/react/docs/perf.html">&larr; Prev</a>
      
      
    </div>
  </div>
</section>


    <footer class="wrap">
      <div class="left">
        A Facebook &amp; Instagram collaboration.<br>
        <a href="/react/acknowledgements.html">Acknowledgements</a>
      </div>
      <div class="right">
        &copy; 2013&ndash;2015 Facebook Inc.<br>
        Documentation licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
      </div>
    </footer>
  </div>
  <div id="fb-root"></div>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-41298772-1', 'facebook.github.io');
    ga('send', 'pageview');

    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");

    (function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=623268441017527";
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));
  </script>
</body>
</html>
